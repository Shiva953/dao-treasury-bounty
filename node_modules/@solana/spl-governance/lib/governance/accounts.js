"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProposalDepositAddress = exports.getGoverningTokenHoldingAddress = exports.getNativeTreasuryAddress = exports.getProgramMetadataAddress = exports.ProgramMetadata = exports.getProposalTransactionAddress = exports.ProposalTransaction = exports.InstructionData = exports.AccountMetaData = exports.getVoteRecordAddress = exports.VoteRecord = exports.VoteWeight = exports.getSignatoryRecordAddress = exports.SignatoryRecord = exports.ProposalDeposit = exports.Proposal = exports.ProposalOption = exports.OptionVoteResult = exports.ProposalState = exports.getTokenOwnerRecordAddress = exports.TokenOwnerRecord = exports.Governance = exports.GovernanceConfig = exports.getRealmConfigAddress = exports.RealmConfigAccount = exports.GoverningTokenConfig = exports.getTokenHoldingAddress = exports.Realm = exports.RealmConfig = exports.GoverningTokenConfigAccountArgs = exports.GoverningTokenConfigArgs = exports.GoverningTokenType = exports.RealmConfigArgs = exports.VoteType = exports.MultiChoiceType = exports.VoteTypeKind = exports.MintMaxVoteWeightSource = exports.MintMaxVoteWeightSourceType = exports.InstructionExecutionFlags = exports.InstructionExecutionStatus = exports.VoteTipping = exports.VoteThreshold = exports.VoteThresholdType = exports.getGovernanceAccountVersion = exports.getAccountTypes = exports.GovernanceAccountType = exports.GOVERNANCE_PROGRAM_SEED = void 0;
var web3_js_1 = require("@solana/web3.js");
var bn_js_1 = __importDefault(require("bn.js"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var instructions_1 = require("./instructions");
var constants_1 = require("../registry/constants");
/// Seed  prefix for Governance Program PDAs
exports.GOVERNANCE_PROGRAM_SEED = 'governance';
var GovernanceAccountType;
(function (GovernanceAccountType) {
    GovernanceAccountType[GovernanceAccountType["Uninitialized"] = 0] = "Uninitialized";
    GovernanceAccountType[GovernanceAccountType["RealmV1"] = 1] = "RealmV1";
    GovernanceAccountType[GovernanceAccountType["TokenOwnerRecordV1"] = 2] = "TokenOwnerRecordV1";
    GovernanceAccountType[GovernanceAccountType["GovernanceV1"] = 3] = "GovernanceV1";
    GovernanceAccountType[GovernanceAccountType["ProgramGovernanceV1"] = 4] = "ProgramGovernanceV1";
    GovernanceAccountType[GovernanceAccountType["ProposalV1"] = 5] = "ProposalV1";
    GovernanceAccountType[GovernanceAccountType["SignatoryRecordV1"] = 6] = "SignatoryRecordV1";
    GovernanceAccountType[GovernanceAccountType["VoteRecordV1"] = 7] = "VoteRecordV1";
    GovernanceAccountType[GovernanceAccountType["ProposalInstructionV1"] = 8] = "ProposalInstructionV1";
    GovernanceAccountType[GovernanceAccountType["MintGovernanceV1"] = 9] = "MintGovernanceV1";
    GovernanceAccountType[GovernanceAccountType["TokenGovernanceV1"] = 10] = "TokenGovernanceV1";
    GovernanceAccountType[GovernanceAccountType["RealmConfig"] = 11] = "RealmConfig";
    GovernanceAccountType[GovernanceAccountType["VoteRecordV2"] = 12] = "VoteRecordV2";
    GovernanceAccountType[GovernanceAccountType["ProposalTransactionV2"] = 13] = "ProposalTransactionV2";
    GovernanceAccountType[GovernanceAccountType["ProposalV2"] = 14] = "ProposalV2";
    GovernanceAccountType[GovernanceAccountType["ProgramMetadata"] = 15] = "ProgramMetadata";
    GovernanceAccountType[GovernanceAccountType["RealmV2"] = 16] = "RealmV2";
    GovernanceAccountType[GovernanceAccountType["TokenOwnerRecordV2"] = 17] = "TokenOwnerRecordV2";
    GovernanceAccountType[GovernanceAccountType["GovernanceV2"] = 18] = "GovernanceV2";
    GovernanceAccountType[GovernanceAccountType["ProgramGovernanceV2"] = 19] = "ProgramGovernanceV2";
    GovernanceAccountType[GovernanceAccountType["MintGovernanceV2"] = 20] = "MintGovernanceV2";
    GovernanceAccountType[GovernanceAccountType["TokenGovernanceV2"] = 21] = "TokenGovernanceV2";
    GovernanceAccountType[GovernanceAccountType["SignatoryRecordV2"] = 22] = "SignatoryRecordV2";
    GovernanceAccountType[GovernanceAccountType["ProposalDeposit"] = 23] = "ProposalDeposit";
})(GovernanceAccountType = exports.GovernanceAccountType || (exports.GovernanceAccountType = {}));
function getAccountTypes(accountClass) {
    switch (accountClass) {
        case Realm:
            return [GovernanceAccountType.RealmV1, GovernanceAccountType.RealmV2];
        case TokenOwnerRecord:
            return [
                GovernanceAccountType.TokenOwnerRecordV1,
                GovernanceAccountType.TokenOwnerRecordV2,
            ];
        case Proposal:
            return [
                GovernanceAccountType.ProposalV1,
                GovernanceAccountType.ProposalV2,
            ];
        case ProposalDeposit:
            return [GovernanceAccountType.ProposalDeposit];
        case SignatoryRecord:
            return [
                GovernanceAccountType.SignatoryRecordV1,
                GovernanceAccountType.SignatoryRecordV2,
            ];
        case VoteRecord:
            return [
                GovernanceAccountType.VoteRecordV1,
                GovernanceAccountType.VoteRecordV2,
            ];
        case ProposalTransaction:
            return [
                GovernanceAccountType.ProposalInstructionV1,
                GovernanceAccountType.ProposalTransactionV2,
            ];
        case RealmConfigAccount:
            return [GovernanceAccountType.RealmConfig];
        case Governance:
            return [
                GovernanceAccountType.GovernanceV1,
                GovernanceAccountType.ProgramGovernanceV1,
                GovernanceAccountType.MintGovernanceV1,
                GovernanceAccountType.TokenGovernanceV1,
                GovernanceAccountType.GovernanceV2,
                GovernanceAccountType.ProgramGovernanceV2,
                GovernanceAccountType.MintGovernanceV2,
                GovernanceAccountType.TokenGovernanceV2,
            ];
        case ProgramMetadata:
            return [GovernanceAccountType.ProgramMetadata];
        default:
            throw Error("".concat(accountClass, " account is not supported"));
    }
}
exports.getAccountTypes = getAccountTypes;
function getGovernanceAccountVersion(accountType) {
    switch (accountType) {
        case GovernanceAccountType.VoteRecordV2:
        case GovernanceAccountType.ProposalTransactionV2:
        case GovernanceAccountType.ProposalV2:
        case GovernanceAccountType.RealmV2:
        case GovernanceAccountType.TokenOwnerRecordV2:
        case GovernanceAccountType.GovernanceV2:
        case GovernanceAccountType.ProgramGovernanceV2:
        case GovernanceAccountType.MintGovernanceV2:
        case GovernanceAccountType.TokenGovernanceV2:
        case GovernanceAccountType.SignatoryRecordV2:
            return constants_1.ACCOUNT_VERSION_V2;
        default:
            return constants_1.ACCOUNT_VERSION_V1;
    }
}
exports.getGovernanceAccountVersion = getGovernanceAccountVersion;
var VoteThresholdType;
(function (VoteThresholdType) {
    // Approval Quorum
    VoteThresholdType[VoteThresholdType["YesVotePercentage"] = 0] = "YesVotePercentage";
    // Not supported in the current version
    VoteThresholdType[VoteThresholdType["QuorumPercentage"] = 1] = "QuorumPercentage";
    // Supported for VERSION >= 3
    VoteThresholdType[VoteThresholdType["Disabled"] = 2] = "Disabled";
})(VoteThresholdType = exports.VoteThresholdType || (exports.VoteThresholdType = {}));
var VoteThreshold = /** @class */ (function () {
    function VoteThreshold(args) {
        this.type = args.type;
        this.value = args.value;
    }
    return VoteThreshold;
}());
exports.VoteThreshold = VoteThreshold;
var VoteTipping;
(function (VoteTipping) {
    VoteTipping[VoteTipping["Strict"] = 0] = "Strict";
    VoteTipping[VoteTipping["Early"] = 1] = "Early";
    VoteTipping[VoteTipping["Disabled"] = 2] = "Disabled";
})(VoteTipping = exports.VoteTipping || (exports.VoteTipping = {}));
var InstructionExecutionStatus;
(function (InstructionExecutionStatus) {
    InstructionExecutionStatus[InstructionExecutionStatus["None"] = 0] = "None";
    InstructionExecutionStatus[InstructionExecutionStatus["Success"] = 1] = "Success";
    InstructionExecutionStatus[InstructionExecutionStatus["Error"] = 2] = "Error";
})(InstructionExecutionStatus = exports.InstructionExecutionStatus || (exports.InstructionExecutionStatus = {}));
var InstructionExecutionFlags;
(function (InstructionExecutionFlags) {
    InstructionExecutionFlags[InstructionExecutionFlags["None"] = 0] = "None";
    InstructionExecutionFlags[InstructionExecutionFlags["Ordered"] = 1] = "Ordered";
    InstructionExecutionFlags[InstructionExecutionFlags["UseTransaction"] = 2] = "UseTransaction";
})(InstructionExecutionFlags = exports.InstructionExecutionFlags || (exports.InstructionExecutionFlags = {}));
var MintMaxVoteWeightSourceType;
(function (MintMaxVoteWeightSourceType) {
    MintMaxVoteWeightSourceType[MintMaxVoteWeightSourceType["SupplyFraction"] = 0] = "SupplyFraction";
    MintMaxVoteWeightSourceType[MintMaxVoteWeightSourceType["Absolute"] = 1] = "Absolute";
})(MintMaxVoteWeightSourceType = exports.MintMaxVoteWeightSourceType || (exports.MintMaxVoteWeightSourceType = {}));
var MintMaxVoteWeightSource = /** @class */ (function () {
    function MintMaxVoteWeightSource(args) {
        this.type = args.type;
        this.value = args.value;
    }
    MintMaxVoteWeightSource.prototype.isFullSupply = function () {
        return (this.type === MintMaxVoteWeightSourceType.SupplyFraction &&
            this.value.cmp(MintMaxVoteWeightSource.SUPPLY_FRACTION_BASE) === 0);
    };
    MintMaxVoteWeightSource.prototype.getSupplyFraction = function () {
        if (this.type !== MintMaxVoteWeightSourceType.SupplyFraction) {
            throw new Error('Max vote weight is not fraction');
        }
        return this.value;
    };
    MintMaxVoteWeightSource.prototype.fmtSupplyFractionPercentage = function () {
        return new bignumber_js_1.default(this.getSupplyFraction())
            .shiftedBy(-MintMaxVoteWeightSource.SUPPLY_FRACTION_DECIMALS + 2)
            .toFormat();
    };
    MintMaxVoteWeightSource.SUPPLY_FRACTION_BASE = new bn_js_1.default(10000000000);
    MintMaxVoteWeightSource.SUPPLY_FRACTION_DECIMALS = 10;
    MintMaxVoteWeightSource.FULL_SUPPLY_FRACTION = new MintMaxVoteWeightSource({
        type: MintMaxVoteWeightSourceType.SupplyFraction,
        value: MintMaxVoteWeightSource.SUPPLY_FRACTION_BASE,
    });
    return MintMaxVoteWeightSource;
}());
exports.MintMaxVoteWeightSource = MintMaxVoteWeightSource;
var VoteTypeKind;
(function (VoteTypeKind) {
    VoteTypeKind[VoteTypeKind["SingleChoice"] = 0] = "SingleChoice";
    VoteTypeKind[VoteTypeKind["MultiChoice"] = 1] = "MultiChoice";
})(VoteTypeKind = exports.VoteTypeKind || (exports.VoteTypeKind = {}));
var MultiChoiceType;
(function (MultiChoiceType) {
    MultiChoiceType[MultiChoiceType["FullWeight"] = 0] = "FullWeight";
    MultiChoiceType[MultiChoiceType["Weighted"] = 1] = "Weighted";
})(MultiChoiceType = exports.MultiChoiceType || (exports.MultiChoiceType = {}));
var VoteType = /** @class */ (function () {
    function VoteType(args) {
        this.type = args.type;
        this.choiceType = args.choiceType;
        this.minVoterOptions = args.minVoterOptions;
        this.maxVoterOptions = args.maxVoterOptions;
        this.maxWinningOptions = args.maxWinningOptions;
    }
    VoteType.prototype.isSingleChoice = function () {
        return this.type === VoteTypeKind.SingleChoice;
    };
    VoteType.SINGLE_CHOICE = new VoteType({
        type: VoteTypeKind.SingleChoice,
        choiceType: undefined,
        minVoterOptions: undefined,
        maxVoterOptions: undefined,
        maxWinningOptions: undefined,
    });
    VoteType.MULTI_CHOICE = function (choiceType, minVoterOptions, maxVoterOptions, maxWinningOptions) {
        return new VoteType({
            type: VoteTypeKind.MultiChoice,
            choiceType: choiceType,
            minVoterOptions: minVoterOptions,
            maxVoterOptions: maxVoterOptions,
            maxWinningOptions: maxWinningOptions,
        });
    };
    return VoteType;
}());
exports.VoteType = VoteType;
var RealmConfigArgs = /** @class */ (function () {
    function RealmConfigArgs(args) {
        this.useCouncilMint = !!args.useCouncilMint;
        this.communityMintMaxVoteWeightSource =
            args.communityMintMaxVoteWeightSource;
        this.minCommunityTokensToCreateGovernance =
            args.minCommunityTokensToCreateGovernance;
        this.useCommunityVoterWeightAddin = args.useCommunityVoterWeightAddin;
        this.useMaxCommunityVoterWeightAddin = args.useMaxCommunityVoterWeightAddin;
        this.communityTokenConfigArgs = args.communityTokenConfigArgs;
        this.councilTokenConfigArgs = args.councilTokenConfigArgs;
    }
    return RealmConfigArgs;
}());
exports.RealmConfigArgs = RealmConfigArgs;
var GoverningTokenType;
(function (GoverningTokenType) {
    GoverningTokenType[GoverningTokenType["Liquid"] = 0] = "Liquid";
    GoverningTokenType[GoverningTokenType["Membership"] = 1] = "Membership";
    GoverningTokenType[GoverningTokenType["Dormant"] = 2] = "Dormant";
})(GoverningTokenType = exports.GoverningTokenType || (exports.GoverningTokenType = {}));
var GoverningTokenConfigArgs = /** @class */ (function () {
    function GoverningTokenConfigArgs(args) {
        this.useVoterWeightAddin = args.useVoterWeightAddin;
        this.useMaxVoterWeightAddin = args.useMaxVoterWeightAddin;
        this.tokenType = args.tokenType;
    }
    return GoverningTokenConfigArgs;
}());
exports.GoverningTokenConfigArgs = GoverningTokenConfigArgs;
var GoverningTokenConfigAccountArgs = /** @class */ (function () {
    function GoverningTokenConfigAccountArgs(args) {
        this.voterWeightAddin = args.voterWeightAddin;
        this.maxVoterWeightAddin = args.maxVoterWeightAddin;
        this.tokenType = args.tokenType;
    }
    return GoverningTokenConfigAccountArgs;
}());
exports.GoverningTokenConfigAccountArgs = GoverningTokenConfigAccountArgs;
var RealmConfig = /** @class */ (function () {
    function RealmConfig(args) {
        this.councilMint = args.councilMint;
        this.communityMintMaxVoteWeightSource =
            args.communityMintMaxVoteWeightSource;
        this.minCommunityTokensToCreateGovernance =
            args.minCommunityTokensToCreateGovernance;
        this.useCommunityVoterWeightAddin = !!args.useCommunityVoterWeightAddin;
        this.useMaxCommunityVoterWeightAddin = !!args.useMaxCommunityVoterWeightAddin;
        this.reserved = args.reserved;
    }
    return RealmConfig;
}());
exports.RealmConfig = RealmConfig;
var Realm = /** @class */ (function () {
    function Realm(args) {
        this.accountType = GovernanceAccountType.RealmV1;
        this.communityMint = args.communityMint;
        this.config = args.config;
        this.reserved = args.reserved;
        this.votingProposalCount = args.votingProposalCount;
        this.authority = args.authority;
        this.name = args.name;
    }
    return Realm;
}());
exports.Realm = Realm;
function getTokenHoldingAddress(programId, realm, governingTokenMint) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, tokenHoldingAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                        realm.toBuffer(),
                        governingTokenMint.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), tokenHoldingAddress = _a[0];
                    return [2 /*return*/, tokenHoldingAddress];
            }
        });
    });
}
exports.getTokenHoldingAddress = getTokenHoldingAddress;
var GoverningTokenConfig = /** @class */ (function () {
    function GoverningTokenConfig(args) {
        this.voterWeightAddin = args.voterWeightAddin;
        this.maxVoterWeightAddin = args.maxVoterWeightAddin;
        this.tokenType = args.tokenType;
        this.reserved = args.reserved;
    }
    return GoverningTokenConfig;
}());
exports.GoverningTokenConfig = GoverningTokenConfig;
var RealmConfigAccount = /** @class */ (function () {
    function RealmConfigAccount(args) {
        this.accountType = GovernanceAccountType.RealmConfig;
        this.realm = args.realm;
        this.communityTokenConfig = args.communityTokenConfig;
        this.councilTokenConfig = args.councilTokenConfig;
        this.reserved = args.reserved;
    }
    return RealmConfigAccount;
}());
exports.RealmConfigAccount = RealmConfigAccount;
function getRealmConfigAddress(programId, realm) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, realmConfigAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([Buffer.from('realm-config'), realm.toBuffer()], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), realmConfigAddress = _a[0];
                    return [2 /*return*/, realmConfigAddress];
            }
        });
    });
}
exports.getRealmConfigAddress = getRealmConfigAddress;
var GovernanceConfig = /** @class */ (function () {
    function GovernanceConfig(args) {
        var _a, _b, _c, _d, _e;
        this.communityVoteThreshold = args.communityVoteThreshold;
        this.minCommunityTokensToCreateProposal =
            args.minCommunityTokensToCreateProposal;
        this.minInstructionHoldUpTime = args.minInstructionHoldUpTime;
        this.baseVotingTime = args.baseVotingTime;
        this.communityVoteTipping = (_a = args.communityVoteTipping) !== null && _a !== void 0 ? _a : VoteTipping.Strict;
        this.minCouncilTokensToCreateProposal =
            args.minCouncilTokensToCreateProposal;
        // VERSION >= 3
        this.councilVoteThreshold =
            (_b = args.councilVoteThreshold) !== null && _b !== void 0 ? _b : args.communityVoteThreshold;
        this.councilVetoVoteThreshold =
            (_c = args.councilVetoVoteThreshold) !== null && _c !== void 0 ? _c : args.communityVoteThreshold;
        this.communityVetoVoteThreshold =
            (_d = args.communityVetoVoteThreshold) !== null && _d !== void 0 ? _d : new VoteThreshold({ type: VoteThresholdType.Disabled });
        this.councilVoteTipping =
            (_e = args.councilVoteTipping) !== null && _e !== void 0 ? _e : this.communityVoteTipping;
        this.votingCoolOffTime = args.votingCoolOffTime;
        this.depositExemptProposalCount = args.depositExemptProposalCount;
    }
    return GovernanceConfig;
}());
exports.GovernanceConfig = GovernanceConfig;
var Governance = /** @class */ (function () {
    function Governance(args) {
        this.accountType = args.accountType;
        this.realm = args.realm;
        this.governedAccount = args.governedAccount;
        this.config = args.config;
        this.reserved = args.reserved;
        this.proposalCount = args.proposalCount;
        this.activeProposalCount = args.activeProposalCount;
    }
    Governance.prototype.isProgramGovernance = function () {
        return (this.accountType === GovernanceAccountType.ProgramGovernanceV1 ||
            this.accountType === GovernanceAccountType.ProgramGovernanceV2);
    };
    Governance.prototype.isAccountGovernance = function () {
        return (this.accountType === GovernanceAccountType.GovernanceV1 ||
            this.accountType === GovernanceAccountType.GovernanceV2);
    };
    Governance.prototype.isMintGovernance = function () {
        return (this.accountType === GovernanceAccountType.MintGovernanceV1 ||
            this.accountType === GovernanceAccountType.MintGovernanceV2);
    };
    Governance.prototype.isTokenGovernance = function () {
        return (this.accountType === GovernanceAccountType.TokenGovernanceV1 ||
            this.accountType === GovernanceAccountType.TokenGovernanceV2);
    };
    return Governance;
}());
exports.Governance = Governance;
var TokenOwnerRecord = /** @class */ (function () {
    function TokenOwnerRecord(args) {
        this.accountType = GovernanceAccountType.TokenOwnerRecordV1;
        this.realm = args.realm;
        this.governingTokenMint = args.governingTokenMint;
        this.governingTokenOwner = args.governingTokenOwner;
        this.governingTokenDepositAmount = args.governingTokenDepositAmount;
        this.unrelinquishedVotesCount = args.unrelinquishedVotesCount;
        this.totalVotesCount = args.totalVotesCount;
        this.outstandingProposalCount = args.outstandingProposalCount;
        this.reserved = args.reserved;
        this.governanceDelegate = args.governanceDelegate;
        this.version = args.version;
    }
    return TokenOwnerRecord;
}());
exports.TokenOwnerRecord = TokenOwnerRecord;
function getTokenOwnerRecordAddress(programId, realm, governingTokenMint, governingTokenOwner) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, tokenOwnerRecordAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                        realm.toBuffer(),
                        governingTokenMint.toBuffer(),
                        governingTokenOwner.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), tokenOwnerRecordAddress = _a[0];
                    return [2 /*return*/, tokenOwnerRecordAddress];
            }
        });
    });
}
exports.getTokenOwnerRecordAddress = getTokenOwnerRecordAddress;
var ProposalState;
(function (ProposalState) {
    ProposalState[ProposalState["Draft"] = 0] = "Draft";
    ProposalState[ProposalState["SigningOff"] = 1] = "SigningOff";
    ProposalState[ProposalState["Voting"] = 2] = "Voting";
    ProposalState[ProposalState["Succeeded"] = 3] = "Succeeded";
    ProposalState[ProposalState["Executing"] = 4] = "Executing";
    ProposalState[ProposalState["Completed"] = 5] = "Completed";
    ProposalState[ProposalState["Cancelled"] = 6] = "Cancelled";
    ProposalState[ProposalState["Defeated"] = 7] = "Defeated";
    ProposalState[ProposalState["ExecutingWithErrors"] = 8] = "ExecutingWithErrors";
    ProposalState[ProposalState["Vetoed"] = 9] = "Vetoed";
})(ProposalState = exports.ProposalState || (exports.ProposalState = {}));
var OptionVoteResult;
(function (OptionVoteResult) {
    OptionVoteResult[OptionVoteResult["None"] = 0] = "None";
    OptionVoteResult[OptionVoteResult["Succeeded"] = 1] = "Succeeded";
    OptionVoteResult[OptionVoteResult["Defeated"] = 2] = "Defeated";
})(OptionVoteResult = exports.OptionVoteResult || (exports.OptionVoteResult = {}));
var ProposalOption = /** @class */ (function () {
    function ProposalOption(args) {
        this.label = args.label;
        this.voteWeight = args.voteWeight;
        this.voteResult = args.voteResult;
        this.instructionsExecutedCount = args.instructionsExecutedCount;
        this.instructionsCount = args.instructionsCount;
        this.instructionsNextIndex = args.instructionsNextIndex;
    }
    return ProposalOption;
}());
exports.ProposalOption = ProposalOption;
var Proposal = /** @class */ (function () {
    function Proposal(args) {
        this.accountType = args.accountType;
        this.governance = args.governance;
        this.governingTokenMint = args.governingTokenMint;
        this.state = args.state;
        this.tokenOwnerRecord = args.tokenOwnerRecord;
        this.signatoriesCount = args.signatoriesCount;
        this.signatoriesSignedOffCount = args.signatoriesSignedOffCount;
        this.descriptionLink = args.descriptionLink;
        this.name = args.name;
        // V1
        this.yesVotesCount = args.yesVotesCount;
        this.noVotesCount = args.noVotesCount;
        this.instructionsExecutedCount = args.instructionsExecutedCount;
        this.instructionsCount = args.instructionsCount;
        this.instructionsNextIndex = args.instructionsNextIndex;
        //
        // V2
        this.voteType = args.voteType;
        this.options = args.options;
        this.denyVoteWeight = args.denyVoteWeight;
        this.reserved1 = args.reserved1;
        this.abstainVoteWeight = args.abstainVoteWeight;
        this.startVotingAt = args.startVotingAt;
        this.maxVotingTime = args.maxVotingTime;
        this.draftAt = args.draftAt;
        this.signingOffAt = args.signingOffAt;
        this.votingAt = args.votingAt;
        this.votingAtSlot = args.votingAtSlot;
        this.votingCompletedAt = args.votingCompletedAt;
        this.executingAt = args.executingAt;
        this.closedAt = args.closedAt;
        this.executionFlags = args.executionFlags;
        this.maxVoteWeight = args.maxVoteWeight;
        this.voteThreshold = args.voteThreshold;
        // V3
        this.vetoVoteWeight = args.vetoVoteWeight;
    }
    /// Returns true if Proposal is in state when no voting can happen any longer
    Proposal.prototype.isVoteFinalized = function () {
        switch (this.state) {
            case ProposalState.Succeeded:
            case ProposalState.Executing:
            case ProposalState.Completed:
            case ProposalState.Cancelled:
            case ProposalState.Defeated:
            case ProposalState.ExecutingWithErrors:
            case ProposalState.Vetoed:
                return true;
            case ProposalState.Draft:
            case ProposalState.SigningOff:
            case ProposalState.Voting:
                return false;
        }
    };
    Proposal.prototype.isFinalState = function () {
        // 1) ExecutingWithErrors is not really a final state, it's undefined.
        //    However it usually indicates none recoverable execution error so we treat is as final for the ui purposes
        // 2) Succeeded with no instructions is also treated as final since it can't transition any longer
        //    It really doesn't make any sense but until it's solved in the program we have to consider it as final in the ui
        switch (this.state) {
            case ProposalState.Completed:
            case ProposalState.Cancelled:
            case ProposalState.Defeated:
            case ProposalState.ExecutingWithErrors:
            case ProposalState.Vetoed:
                return true;
            case ProposalState.Succeeded:
                return this.instructionsCount === 0;
            case ProposalState.Executing:
            case ProposalState.Draft:
            case ProposalState.SigningOff:
            case ProposalState.Voting:
                return false;
        }
    };
    Proposal.prototype.getStateTimestamp = function () {
        switch (this.state) {
            case ProposalState.Succeeded:
            case ProposalState.Defeated:
            case ProposalState.Vetoed:
                return this.votingCompletedAt ? this.votingCompletedAt.toNumber() : 0;
            case ProposalState.Completed:
            case ProposalState.Cancelled:
                return this.closedAt ? this.closedAt.toNumber() : 0;
            case ProposalState.Executing:
            case ProposalState.ExecutingWithErrors:
                return this.executingAt ? this.executingAt.toNumber() : 0;
            case ProposalState.Draft:
                return this.draftAt.toNumber();
            case ProposalState.SigningOff:
                return this.signingOffAt ? this.signingOffAt.toNumber() : 0;
            case ProposalState.Voting:
                return this.votingAt ? this.votingAt.toNumber() : 0;
        }
    };
    Proposal.prototype.getStateSortRank = function () {
        // Always show proposals in voting state at the top
        if (this.state === ProposalState.Voting) {
            return 2;
        }
        // Then show proposals in pending state and finalized at the end
        return this.isFinalState() ? 0 : 1;
    };
    /// Returns true if Proposal has not been voted on yet
    Proposal.prototype.isPreVotingState = function () {
        return !this.votingAtSlot;
    };
    Proposal.prototype.getYesVoteOption = function () {
        if (this.options.length !== 1 && !this.voteType.isSingleChoice()) {
            throw new Error('Proposal is not Yes/No vote');
        }
        return this.options[0];
    };
    Proposal.prototype.getYesVoteCount = function () {
        switch (this.accountType) {
            case GovernanceAccountType.ProposalV1:
                return this.yesVotesCount;
            case GovernanceAccountType.ProposalV2:
                return this.getYesVoteOption().voteWeight;
            default:
                throw new Error("Invalid account type ".concat(this.accountType));
        }
    };
    Proposal.prototype.getNoVoteCount = function () {
        switch (this.accountType) {
            case GovernanceAccountType.ProposalV1:
                return this.noVotesCount;
            case GovernanceAccountType.ProposalV2:
                return this.denyVoteWeight;
            default:
                throw new Error("Invalid account type ".concat(this.accountType));
        }
    };
    Proposal.prototype.getTimeToVoteEnd = function (governance) {
        var _a, _b;
        var unixTimestampInSeconds = Date.now() / 1000;
        var baseVotingTime = this.isPreVotingState()
            ? governance.config.baseVotingTime
            : ((_b = (_a = this.votingAt) === null || _a === void 0 ? void 0 : _a.toNumber()) !== null && _b !== void 0 ? _b : 0) +
                governance.config.baseVotingTime -
                unixTimestampInSeconds;
        return baseVotingTime + governance.config.votingCoolOffTime;
    };
    Proposal.prototype.hasVoteTimeEnded = function (governance) {
        return this.getTimeToVoteEnd(governance) <= 0;
    };
    Proposal.prototype.canCancel = function (governance) {
        if (this.state === ProposalState.Draft ||
            this.state === ProposalState.SigningOff) {
            return true;
        }
        if (this.state === ProposalState.Voting &&
            !this.hasVoteTimeEnded(governance)) {
            return true;
        }
        return false;
    };
    Proposal.prototype.canWalletCancel = function (governance, proposalOwner, walletPk) {
        var _a;
        if (!this.canCancel(governance)) {
            return false;
        }
        return (proposalOwner.governingTokenOwner.equals(walletPk) ||
            ((_a = proposalOwner.governanceDelegate) === null || _a === void 0 ? void 0 : _a.equals(walletPk)));
    };
    return Proposal;
}());
exports.Proposal = Proposal;
var ProposalDeposit = /** @class */ (function () {
    function ProposalDeposit(args) {
        this.accountType = GovernanceAccountType.ProposalDeposit;
        this.proposal = args.proposal;
        this.depositPayer = args.depositPayer;
    }
    return ProposalDeposit;
}());
exports.ProposalDeposit = ProposalDeposit;
var SignatoryRecord = /** @class */ (function () {
    function SignatoryRecord(args) {
        this.accountType = GovernanceAccountType.SignatoryRecordV1;
        this.proposal = args.proposal;
        this.signatory = args.signatory;
        this.signedOff = !!args.signedOff;
    }
    return SignatoryRecord;
}());
exports.SignatoryRecord = SignatoryRecord;
function getSignatoryRecordAddress(programId, proposal, signatory) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, signatoryRecordAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                        proposal.toBuffer(),
                        signatory.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), signatoryRecordAddress = _a[0];
                    return [2 /*return*/, signatoryRecordAddress];
            }
        });
    });
}
exports.getSignatoryRecordAddress = getSignatoryRecordAddress;
var VoteWeight = /** @class */ (function () {
    function VoteWeight(args) {
        this.yes = args.yes;
        this.no = args.no;
    }
    return VoteWeight;
}());
exports.VoteWeight = VoteWeight;
var VoteRecord = /** @class */ (function () {
    // -------------------------------
    function VoteRecord(args) {
        this.accountType = args.accountType;
        this.proposal = args.proposal;
        this.governingTokenOwner = args.governingTokenOwner;
        this.isRelinquished = !!args.isRelinquished;
        // V1
        this.voteWeight = args.voteWeight;
        // V2 -------------------------------
        this.voterWeight = args.voterWeight;
        this.vote = args.vote;
        // -------------------------------
    }
    VoteRecord.prototype.getNoVoteWeight = function () {
        var _a, _b;
        switch (this.accountType) {
            case GovernanceAccountType.VoteRecordV1: {
                return (_a = this.voteWeight) === null || _a === void 0 ? void 0 : _a.no;
            }
            case GovernanceAccountType.VoteRecordV2: {
                switch ((_b = this.vote) === null || _b === void 0 ? void 0 : _b.voteType) {
                    case instructions_1.VoteKind.Approve: {
                        return undefined;
                    }
                    case instructions_1.VoteKind.Deny: {
                        return this.voterWeight;
                    }
                    default:
                        throw new Error('Invalid voteKind');
                }
            }
            default:
                throw new Error("Invalid account type ".concat(this.accountType, " "));
        }
    };
    VoteRecord.prototype.getYesVoteWeight = function () {
        var _a, _b;
        switch (this.accountType) {
            case GovernanceAccountType.VoteRecordV1: {
                return (_a = this.voteWeight) === null || _a === void 0 ? void 0 : _a.yes;
            }
            case GovernanceAccountType.VoteRecordV2: {
                switch ((_b = this.vote) === null || _b === void 0 ? void 0 : _b.voteType) {
                    case instructions_1.VoteKind.Approve: {
                        return this.voterWeight;
                    }
                    case instructions_1.VoteKind.Deny: {
                        return undefined;
                    }
                    default:
                        throw new Error('Invalid voteKind');
                }
            }
            default:
                throw new Error("Invalid account type ".concat(this.accountType, " "));
        }
    };
    return VoteRecord;
}());
exports.VoteRecord = VoteRecord;
function getVoteRecordAddress(programId, proposal, tokenOwnerRecord) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, voteRecordAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                        proposal.toBuffer(),
                        tokenOwnerRecord.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), voteRecordAddress = _a[0];
                    return [2 /*return*/, voteRecordAddress];
            }
        });
    });
}
exports.getVoteRecordAddress = getVoteRecordAddress;
var AccountMetaData = /** @class */ (function () {
    function AccountMetaData(args) {
        this.pubkey = args.pubkey;
        this.isSigner = !!args.isSigner;
        this.isWritable = !!args.isWritable;
    }
    return AccountMetaData;
}());
exports.AccountMetaData = AccountMetaData;
var InstructionData = /** @class */ (function () {
    function InstructionData(args) {
        this.programId = args.programId;
        this.accounts = args.accounts;
        this.data = args.data;
    }
    return InstructionData;
}());
exports.InstructionData = InstructionData;
var ProposalTransaction = /** @class */ (function () {
    function ProposalTransaction(args) {
        this.accountType = args.accountType;
        this.proposal = args.proposal;
        this.instructionIndex = args.instructionIndex;
        this.optionIndex = args.optionIndex;
        this.holdUpTime = args.holdUpTime;
        this.instruction = args.instruction;
        this.executedAt = args.executedAt;
        this.executionStatus = args.executionStatus;
        this.instructions = args.instructions;
    }
    ProposalTransaction.prototype.getSingleInstruction = function () {
        if (this.accountType === GovernanceAccountType.ProposalInstructionV1) {
            return this.instruction;
        }
        if (this.instructions.length === 0) {
            throw new Error("Transaction has no instructions");
        }
        if (this.instructions.length > 1) {
            throw new Error("Transaction has multiple instructions");
        }
        return this.instructions[0];
    };
    ProposalTransaction.prototype.getAllInstructions = function () {
        if (this.accountType === GovernanceAccountType.ProposalInstructionV1) {
            return [this.instruction];
        }
        return this.instructions;
    };
    return ProposalTransaction;
}());
exports.ProposalTransaction = ProposalTransaction;
function getProposalTransactionAddress(programId, programVersion, proposal, optionIndex, transactionIndex) {
    return __awaiter(this, void 0, void 0, function () {
        var optionIndexBuffer, instructionIndexBuffer, seeds, _a, instructionAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    optionIndexBuffer = Buffer.alloc(1);
                    optionIndexBuffer.writeUInt8(optionIndex);
                    instructionIndexBuffer = Buffer.alloc(2);
                    instructionIndexBuffer.writeInt16LE(transactionIndex, 0);
                    seeds = programVersion === constants_1.PROGRAM_VERSION_V1
                        ? [
                            Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                            proposal.toBuffer(),
                            instructionIndexBuffer,
                        ]
                        : [
                            Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                            proposal.toBuffer(),
                            optionIndexBuffer,
                            instructionIndexBuffer,
                        ];
                    return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress(seeds, programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), instructionAddress = _a[0];
                    return [2 /*return*/, instructionAddress];
            }
        });
    });
}
exports.getProposalTransactionAddress = getProposalTransactionAddress;
var ProgramMetadata = /** @class */ (function () {
    function ProgramMetadata(args) {
        this.accountType = GovernanceAccountType.ProgramMetadata;
        this.updatedAt = args.updatedAt;
        this.reserved = args.reserved;
        this.version = args.version;
    }
    return ProgramMetadata;
}());
exports.ProgramMetadata = ProgramMetadata;
function getProgramMetadataAddress(programId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, signatoryRecordAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([Buffer.from('metadata')], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), signatoryRecordAddress = _a[0];
                    return [2 /*return*/, signatoryRecordAddress];
            }
        });
    });
}
exports.getProgramMetadataAddress = getProgramMetadataAddress;
function getNativeTreasuryAddress(programId, governance) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, signatoryRecordAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([Buffer.from('native-treasury'), governance.toBuffer()], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), signatoryRecordAddress = _a[0];
                    return [2 /*return*/, signatoryRecordAddress];
            }
        });
    });
}
exports.getNativeTreasuryAddress = getNativeTreasuryAddress;
function getGoverningTokenHoldingAddress(programId, realm, governingTokenMint) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, governingTokenHoldingAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from(exports.GOVERNANCE_PROGRAM_SEED),
                        realm.toBuffer(),
                        governingTokenMint.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), governingTokenHoldingAddress = _a[0];
                    return [2 /*return*/, governingTokenHoldingAddress];
            }
        });
    });
}
exports.getGoverningTokenHoldingAddress = getGoverningTokenHoldingAddress;
function getProposalDepositAddress(programId, proposal, proposalDepositPayer) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, proposalDepositAddress;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, web3_js_1.PublicKey.findProgramAddress([
                        Buffer.from('proposal-deposit'),
                        proposal.toBuffer(),
                        proposalDepositPayer.toBuffer(),
                    ], programId)];
                case 1:
                    _a = __read.apply(void 0, [_b.sent(), 1]), proposalDepositAddress = _a[0];
                    return [2 /*return*/, proposalDepositAddress];
            }
        });
    });
}
exports.getProposalDepositAddress = getProposalDepositAddress;
//# sourceMappingURL=accounts.js.map