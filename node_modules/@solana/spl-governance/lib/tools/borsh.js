"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeBorsh = void 0;
var web3_js_1 = require("@solana/web3.js");
var borsh_1 = require("borsh");
borsh_1.BinaryReader.prototype.readPubkey = function () {
    var reader = this;
    var array = reader.readFixedArray(32);
    return new web3_js_1.PublicKey(array);
};
borsh_1.BinaryWriter.prototype.writePubkey = function (value) {
    var writer = this;
    writer.writeFixedArray(value.toBuffer());
};
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function deserializeField(schema, fieldName, fieldType, reader) {
    try {
        if (typeof fieldType === 'string') {
            return reader["read".concat(capitalizeFirstLetter(fieldType))]();
        }
        if (fieldType instanceof Array) {
            if (typeof fieldType[0] === 'number') {
                return reader.readFixedArray(fieldType[0]);
            }
            return reader.readArray(function () {
                return deserializeField(schema, fieldName, fieldType[0], reader);
            });
        }
        if (fieldType.kind === 'option') {
            var option = reader.readU8();
            if (option) {
                return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return undefined;
        }
        return deserializeStruct(schema, fieldType, reader);
    }
    catch (error) {
        if (error instanceof borsh_1.BorshError) {
            error.addToFieldPath(fieldName);
        }
        throw error;
    }
}
function deserializeStruct(schema, classType, reader) {
    var e_1, _a, _b;
    var structSchema = schema.get(classType);
    if (!structSchema) {
        throw new borsh_1.BorshError("Class ".concat(classType.name, " is missing in schema"));
    }
    if (structSchema.kind === 'struct') {
        var result = {};
        try {
            for (var _c = __values(schema.get(classType).fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), fieldName = _e[0], fieldType = _e[1];
                result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return new classType(result);
    }
    if (structSchema.kind === 'enum') {
        var idx = reader.readU8();
        if (idx >= structSchema.values.length) {
            throw new borsh_1.BorshError("Enum index: ".concat(idx, " is out of range"));
        }
        var _f = __read(structSchema.values[idx], 2), fieldName = _f[0], fieldType = _f[1];
        var fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType((_b = {}, _b[fieldName] = fieldValue, _b));
    }
    throw new borsh_1.BorshError("Unexpected schema kind: ".concat(structSchema.kind, " for ").concat(classType.constructor.name));
}
/// Deserializes object from bytes using schema.
function deserializeBorsh(schema, classType, buffer) {
    var reader = new borsh_1.BinaryReader(buffer);
    return deserializeStruct(schema, classType, reader);
}
exports.deserializeBorsh = deserializeBorsh;
//# sourceMappingURL=borsh.js.map